// ===============================================================================
// Authors: AFRL/RQQA
// Organization: Air Force Research Laboratory, Aerospace Systems Directorate, Power and Control Division
// 
// Copyright (c) 2017 Government of the United State of America, as represented by
// the Secretary of the Air Force.  No copyright is claimed in the United States under
// Title 17, U.S. Code.  All Other Rights Reserved.
// ===============================================================================

package avtas.lmcp.lmcpgen;

import java.io.File;
import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Date;

/* This file was autogenerated from LmcpGen */
class PythonMethods {

    public static String series_dir(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + info.namespace;
    }
    
    public static String create_inits(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        /**
         * This method exists solely to create blank __init__.py files in folders that do not contain a series __init__.py file in order to 
         * enable python to see these directories as part of a package structure.
         */
        int len = info.namespace.split("/").length;
        File parent = outfile.getParentFile();
        //System.out.println("******* Parent: " + parent.getAbsolutePath() + " *********");
        for(int i = 1; i < len; i++){
            parent = parent.getParentFile();
            File blank_init = new File(parent, "__init__.py");
            if(!blank_init.exists()){
                blank_init.createNewFile();
            }
        }
        return "";
    }

    public static String namespace(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return series_dir(infos, info, outfile, st, en, ws);
    }

    public static String series_name(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + "\"" + info.seriesName + "\"";
    }

    // Returns the date that the package was made
    public static String creation_date(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + DateFormat.getDateInstance(DateFormat.FULL).format(new Date());
    }

    public static String lmcp_type(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + st.id;
    }

    public static String datatype_name(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + st.name;
    }

    public static String full_datatype_name(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        String str = "";
        String[] tmp = info.namespace.split("/");
        for (int i = 0; i < tmp.length; i++) {
            str += tmp[i] + ".";
        }
        return ws + str + st.name;
    }
    
    public static String classname(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + st.name;
    }

    public static String extends_name(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return st.extends_name.isEmpty() ? "LMCPObject.LMCPObject" : st.extends_name + "." + st.extends_name;
    }

    public static String list_imports(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        ArrayList<String> namespaces = new ArrayList<String>();
        ArrayList<String> structs = new ArrayList<String>();
        if(!st.extends_name.isEmpty()){
            namespaces.add(getNamespaceForSeries(infos, st));
            structs.add(st.extends_name);
        }
        for(FieldInfo f : st.fields){
            if(f.isStruct || f.isEnum){
                String namespace = getNamespaceForType(infos, f);
                if(!structs.contains(f.type) && namespace != null){
                    namespaces.add(namespace);
                    structs.add(f.type);
                }
            }
        }
        for(int i = 0; i < namespaces.size(); i++){
            String import_path = namespaces.get(i).replace("/", ".");
            buf.append(ws + "from " + import_path + " import " + structs.get(i) + "\n");
        }
        return buf.toString();
    }

    public static String import_all_series(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(MDMInfo i : infos){
            if(i.seriesNameAsLong == 0)
            {
                continue;
            }
            if (info == null || !info.seriesName.equals(i.seriesName)) {
                String import_path = i.namespace.replace("/", ".");
                buf.append(ws + "import " + import_path + "\n");
            }
        }
        return buf.toString();
    }

    public static String list_all_series_modules(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String seriesDir = series_dir(infos, info, outfile, st, en, "");
        buf.append(ws + "__all__ = [ \"SeriesEnum\", ");
        for (StructInfo d : info.structs) {
            buf.append("\"" + d.name + "\", ");
        }
        for (EnumInfo d : info.enums) {
            buf.append("\"" + d.name + "\", ");
        }
        buf.append("]\n");
        return buf.toString();
    }

    public static String import_all(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String seriesDir = series_dir(infos, info, outfile, st, en, "");
        for (StructInfo d : info.structs) {
            buf.append(ws + "from " + seriesDir + " import " + d.name + "\n");
        }
        for (EnumInfo d : info.enums) {
            buf.append(ws + "from " + seriesDir + " import " + d.name + "\n");
        }
        return buf.toString();
    }

    public static String enum_name(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        return ws + en.name;
    }

    public static String enum_gen_entries(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(EnumInfo.EnumEntry entry : en.entries) {
            buf.append(ws + entry.name + " = " + entry.value + "\n");
        }
        return buf.toString();
    }

    public static String enum_from_string(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(EnumInfo.EnumEntry entry : en.entries) {
            buf.append(ws + "if str == \"" + entry.name + "\": return " + en.name + "." + entry.name + "\n");
        }
        return buf.toString();
    }

    public static String enum_from_int(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(EnumInfo.EnumEntry entry : en.entries) {
            buf.append(ws + "if val == " + en.name + "." + entry.name + ": return \"" + entry.name + "\"\n");
        }
        buf.append(ws + "return " + en.name + "." + en.entries.get(0).name + "\n");
        return buf.toString();
    }

    public static String call_superclass_init(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String superClass = extends_name(infos, info, outfile, st, en, ws);
        if(!superClass.equals("LMCPObject.LMCPObject")){
            buf.append(ws + superClass + ".__init__(self)");
        }
        return buf.toString();
    }

    public static String define_vars(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        String str = "";
        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (!f.isArray) {
                if (f.isStruct) {
                    str += ws + name + " = ";
                    str += f.defaultVal.equalsIgnoreCase("null") ? "None" : f.type + "." + f.type + "()";
                } else if (f.isEnum) {
                    str += ws + name + " = " + f.type + "." + f.type + "." + f.defaultVal;
                } else if (f.type.equalsIgnoreCase("string")) {
                    str += ws + name + " = \"" + f.defaultVal + "\"";
                } else {
                    String dv;
                    if(f.defaultVal.equalsIgnoreCase("false")||f.defaultVal.equalsIgnoreCase("true")){
                        if(f.defaultVal.equalsIgnoreCase("false"))
                            dv = "False";
                        else {
                            dv = "True";
                        }
                    } else {
                        dv = f.defaultVal.isEmpty() ?  getPythonType(f.type) +  "(0)" : f.defaultVal;
                    }
                    str += ws + name + " = " + dv;
                }
            // variable length array
            } else if (f.length < 0) {
                str += ws + name + " = []";
            } else {
                //fixed length array
                if (f.isStruct) {
                    str += ws + name + " = ";
                    str += f.defaultVal.equalsIgnoreCase("null") ? "[None]" : "[" + f.type + "()]";
                } else if (f.isEnum) {
                    str += ws + name + " = [" + f.type + "." + f.type + "." + f.defaultVal + "]";
                } else if (f.type.equals("string")) {
                    str += ws + name + " = [\"" + f.defaultVal + "\"]";
                } else {
                    String dv = f.defaultVal.isEmpty() ? "[0]" : "[" + f.defaultVal + "]";
                    str += ws + name + " = " + dv;
                }
                str += "*" + f.length;
            }
            str += "   #" + f.type + "\n";
        }
        return str;
    }

    public static String pack_vars(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String superClass = extends_name(infos, info, outfile, st, en, ws);
        buf.append(ws + "buffer.extend(" + superClass + ".pack(self))\n");
        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (!f.isArray) {
                if (f.type.equalsIgnoreCase("string")) {
                    buf.append(ws + "buffer.append(struct.pack(\">H\", len(" + name + ") ))\n");
                    buf.append(ws + "if len(" + name + ") > 0:\n");
                    buf.append(ws + "    buffer.append(struct.pack( repr(len(" + name + ")) + \"s\", str(" + name + ")))\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "boolChar = 1 if " + name + " == True else 0\n");
                    buf.append(ws + "buffer.append(struct.pack(\">B\",boolChar))\n");
                } else if (f.isStruct) {
                    buf.append(ws + "buffer.append(struct.pack(\"B\", " + name + " != None ))\n");
                    buf.append(ws + "if " + name + " != None:\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">q\", " + name + ".SERIES_NAME_ID))\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">I\", " + name + ".LMCP_TYPE))\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">H\", " + name + ".SERIES_VERSION))\n");
                    buf.append(ws + "    buffer.append(" + name + ".pack())\n");
                } else {
                    buf.append(ws + "buffer.append(struct.pack(\">" + getStructTypeString(f) + "\", " + name + "))\n");
                }
            } // field is an array
            else {
                // for variable length arrays, precede with length value
                if (f.length < 0) {
                    if (f.isLargeArray) {
                       buf.append(ws + "buffer.append(struct.pack(\">I\", len(" + name + ") ))\n"); 
                    } else {
                        buf.append(ws + "buffer.append(struct.pack(\">H\", len(" + name + ") ))\n");
                    }
                }
                if (f.isStruct) {
                    buf.append(ws + "for x in " + name + ":\n");
                    buf.append(ws + "   buffer.append(struct.pack(\"B\", x != None ))\n");
                    buf.append(ws + "   if x != None:\n");
                    buf.append(ws + "       buffer.append(struct.pack(\">q\", x.SERIES_NAME_ID))\n");
                    buf.append(ws + "       buffer.append(struct.pack(\">I\", x.LMCP_TYPE))\n");
                    buf.append(ws + "       buffer.append(struct.pack(\">H\", x.SERIES_VERSION))\n");
                    buf.append(ws + "       buffer.append(x.pack())\n");
                } else if (f.type.equalsIgnoreCase("string")) {
                    buf.append(ws + "for x in " + name + ":\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">H\", len(x) ))\n");
                    buf.append(ws + "    if len(x) > 0:\n");
                    buf.append(ws + "        buffer.append(struct.pack( repr(len(x)) + \"s\", str(" + name + "[x])))\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "for x in " + name + ":\n");
                    buf.append(ws + "    boolChar = 1 if x == True else 0\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">B\",boolChar))\n");
                } else {
                    buf.append(ws + "for x in " + name + ":\n");
                    buf.append(ws + "    buffer.append(struct.pack(\">" + getStructTypeString(f) + "\", x ))\n");
                }
            }
        }
        return buf.toString();
    }

    public static String unpack_vars(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String superClass = extends_name(infos, info, outfile, st, en, ws);
        buf.append(ws + "_pos = " + superClass + ".unpack(self, buffer, _pos)\n");
        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (!f.isArray) {
                if (f.type.equalsIgnoreCase("string")) {
                    buf.append(ws + "_strlen = struct.unpack_from(\">H\", buffer, _pos )[0]\n");
                    buf.append(ws + "_pos += 2\n");
                    buf.append(ws + "if _strlen > 0:\n");
                    buf.append(ws + "    " + name + " = struct.unpack_from( repr(_strlen) + \"s\", buffer, _pos )[0]\n");
                    buf.append(ws + "    _pos += _strlen\n");
                    buf.append(ws + "else:\n ");
                    buf.append(ws + "    " + name + " = \"\"\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "boolChar = struct.unpack_from(\">B\", buffer, _pos)[0]\n");
                    buf.append(ws + name + " = True if boolChar == 1 else False\n");
                    buf.append(ws + "_pos += 1\n");
                } else if (f.isStruct) {
                    buf.append(ws + "_valid = struct.unpack_from(\"B\", buffer, _pos )[0]\n");
                    buf.append(ws + "_pos += 1\n");
                    buf.append(ws + "if _valid:\n");
                    buf.append(ws + "    _series = struct.unpack_from(\">q\", buffer, _pos)[0]\n");
                    buf.append(ws + "    _pos += 8\n");
                    buf.append(ws + "    _type = struct.unpack_from(\">I\", buffer, _pos)[0]\n");
                    buf.append(ws + "    _pos += 4\n");
                    buf.append(ws + "    _version = struct.unpack_from(\">H\", buffer, _pos)[0]\n");
                    buf.append(ws + "    _pos += 2\n");
                    buf.append(ws + "    from lmcp import LMCPFactory\n");
                    buf.append(ws + "    " + name + " = LMCPFactory.LMCPFactory().createObject(_series, _version, _type )\n");
                    buf.append(ws + "    _pos = " + name + ".unpack(buffer, _pos)\n");
                    buf.append(ws + "else:\n");
                    buf.append(ws + "    " + name + " = None\n");
                } else {
                    buf.append(ws + name + " = struct.unpack_from(\">" + getStructTypeString(f) + "\", buffer, _pos)[0]\n");
                    buf.append(ws + "_pos += " + sizeOf(f) + "\n");
                }
            } // field is an array
            else {
                // for variable length arrays, precede with length value
                if (f.length < 0) {
                    if (f.isLargeArray) {
                        buf.append(ws + "_arraylen = struct.unpack_from(\">I\", buffer, _pos )[0]\n");
                    } else {
                        buf.append(ws + "_arraylen = struct.unpack_from(\">H\", buffer, _pos )[0]\n");
                    }
                    buf.append(ws + "_arraylen = struct.unpack_from(\">H\", buffer, _pos )[0]\n");
                    buf.append(ws + name + " = [None] * _arraylen\n");
                    buf.append(ws + "_pos += 2\n");
                } else {
                    buf.append(ws + name + " = [None] * " + f.length + "\n");
                    buf.append(ws + "_arraylen = " + f.length + "\n");
                }
                if (f.isStruct) {
                    buf.append(ws + "for x in range(_arraylen):\n");
                    buf.append(ws + "    _valid = struct.unpack_from(\"B\", buffer, _pos )[0]\n");
                    buf.append(ws + "    _pos += 1\n");
                    buf.append(ws + "    if _valid:\n");
                    buf.append(ws + "        _series = struct.unpack_from(\">q\", buffer, _pos)[0]\n");
                    buf.append(ws + "        _pos += 8\n");
                    buf.append(ws + "        _type = struct.unpack_from(\">I\", buffer, _pos)[0]\n");
                    buf.append(ws + "        _pos += 4\n");
                    buf.append(ws + "        _version = struct.unpack_from(\">H\", buffer, _pos)[0]\n");
                    buf.append(ws + "        _pos += 2\n");
                    buf.append(ws + "        from lmcp import LMCPFactory\n");
                    buf.append(ws + "        " + name + "[x] = LMCPFactory.LMCPFactory().createObject(_series, _version, _type )\n");
                    buf.append(ws + "        _pos = " + name + "[x].unpack(buffer, _pos)\n");
                    buf.append(ws + "    else:\n");
                    buf.append(ws + "        " + name + "[x] = None\n");
                } else if (f.type.equalsIgnoreCase("string")) {
                    buf.append(ws + "for x in range(_arraylen):\n");
                    buf.append(ws + "    _strlen = struct.unpack_from(\">H\", buffer, _pos )[0]\n");
                    buf.append(ws + "    _pos += 2\n");
                    buf.append(ws + "    if _strlen > 0:\n");
                    buf.append(ws + "        " + name + "[x] = struct.unpack_from( repr(_strlen) + \"s\", buffer, _pos )[0]\n");
                    buf.append(ws + "        _pos += _strlen\n");
                    buf.append(ws + "    else:\n ");
                    buf.append(ws + "        " + name + "[x] = \"\"\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "for x in range(_arraylen):\n");
                    buf.append(ws + "    boolChar = struct.unpack_from(\">B\", buffer, _pos)[0]\n");
                    buf.append(ws + "    " + name + "[x] = True if boolChar == 1 else False\n");
                    buf.append(ws + "    _pos += 1\n");
                } else {
                    String typeStr = "\">\" + repr(_arraylen) + \"" + getStructTypeString(f) + "\"";
                    buf.append(ws + "if _arraylen > 0:\n");
                    buf.append(ws + "    " + name + " = struct.unpack_from(" + typeStr + ", buffer, _pos )\n");
                    buf.append(ws + "    _pos += " + sizeOf(f) + " * _arraylen\n");
                }
            }
        }
        buf.append(ws + "return _pos\n");
        return buf.toString();
    }

    public static String gets_and_sets(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for (FieldInfo f : st.fields) {
            buf.append(ws + "def get_" + f.name + "(self):\n");
            buf.append(ws + "    return self." + f.name + "\n\n");
            if (!f.isArray) {
                buf.append(ws + "def set_" + f.name + "(self, value):\n");
                if (!f.isStruct && !f.isEnum) {
                    buf.append(ws + "    self." + f.name + " = " + getPythonType(f.type) + "( value )\n\n");
                } else {
                    buf.append(ws + "    self." + f.name + " = value \n\n");
                }
            }
        }
        return buf.toString();
    }

    public static String print_vars(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        String superClass = extends_name(infos, info, outfile, st, en, ws);
        buf.append(ws + "buf = " + superClass + ".toString(self)\n");
        buf.append(ws + "buf += \"From " + st.name + ":\\n\"" + "\n");
        for (FieldInfo f : st.fields) {
            String name = "str( self." + f.name + " )";
            buf.append(ws + "buf +=    \"" + f.name + " = \" + " + name + " + \"\\n\" " + "\n");
        }
        return buf.toString();
    }

    public static String enum_series_name_setup(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + "SERIES_NAME = " + "\"" + info.seriesName + "\"" + "\n");
        buf.append(ws + "#Series Name turned into a long for quick comparisons.\n");
        buf.append(ws + "SERIES_NAME_ID = " + info.seriesNameAsLong + "\n");
        buf.append(ws + "SERIES_VERSION = " + info.version + "\n");
        return buf.toString();
    }

    public static String struct_series_name_setup(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + "#Series Name turned into a long for quick comparisons.\n");
        buf.append(ws + "self.SERIES_NAME_ID = " + info.seriesNameAsLong + "\n");
        buf.append(ws + "self.SERIES_VERSION = " + info.version + "\n");
        return buf.toString();
    }

    public static String list_name_for_type(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < info.structs.length; i++) {
            buf.append( ws + "if(type_ ==  " + info.structs[i].id + "): return \"" + info.structs[i].name + "\"\n" );
        }
        return buf.toString();
    }

    public static String list_type_for_name(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        String ret = "";
            for (StructInfo s : info.structs) {
                ret += ws + "if ( name == \"" + s.name + "\"): return " + s.id + "\n";
            }
        return ret;
    }

    public static String list_instance_for_type(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for (int i = 0; i < info.structs.length; i++) {
            buf.append( ws + "if(type_ ==  " + info.structs[i].id + "): return " + info.structs[i].name + "." + info.structs[i].name + "()\n" );
        }
        return buf.toString();
    }

    public static String import_each_module(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(MDMInfo in : infos){
            if(in.seriesName.equals(info.seriesName)){
                for(StructInfo si : in.structs){
                    buf.append(ws + "from . import " + si.name + "\n");
                }
            }
        }
        return buf.toString();
    }


    public static String series_create_object(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for (StructInfo d : info.structs) {
            buf.append(ws + "if LMCPTypeNumber == " + d.id + ":\n");
            buf.append(ws + "   return " + d.name + "." + d.name + "()\n");
        }
        buf.append(ws + "return None");
        return buf.toString();
    }

    public static String create_object(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + "if series_id in self.series_enums.keys():\n");
        buf.append(ws + "    series_enum = self.series_enums[series_id]\n");
        buf.append(ws + "    if series_enum.SERIES_VERSION == version:\n");
        buf.append(ws + "        return series_enum.SeriesEnum().getInstance(object_type)\n");
        return buf.toString();
    }

    public static String initialize_series_enums(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(MDMInfo i : infos){
            if(i.seriesNameAsLong == 0)
            {
                continue;
            }
            String[] splits = i.namespace.split("/");
            String name = i.namespace.replace("/", ".");
            buf.append(ws + "from " + name + " import SeriesEnum\n");
            buf.append(ws + "self.addSeries(SeriesEnum)\n");
        }
        return buf.toString();
    }

    public static String get_object_from_buffer(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + "obj = createObject( getLMCPType(buffer))\n");
        buf.append(ws + "if obj != None:\n");
        buf.append(ws + "   obj.unpack(buffer[22:])\n");
        return buf.toString();
    }

    public static String get_lmcp_name(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for (StructInfo d : info.structs) {
            buf.append(ws + "if LMCPTypeNumber == " + d.id + ":\n");
            buf.append(ws + "    return \"" + d.name + "\"\n");
        }
        buf.append(ws + "return None");
        return buf.toString();
    }

    public static String import_all_messages(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(MDMInfo i : infos){
            if(i.seriesNameAsLong == 0)
            {
                continue;
            }
            String import_path = i.namespace.replace("/",".");
            for(StructInfo si : i.structs){
                buf.append(ws + "from " + import_path + " import " + si.name + "\n");
            }
        }
        return buf.toString();
    }

    public static String pack_all_messages(MDMInfo[] infos, MDMInfo info, final File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(MDMInfo i : infos){
            if(i.seriesNameAsLong == 0)
            {
                continue;
            }
            for(StructInfo si : i.structs){
                buf.append(ws + "#Pack " + si.name + "\n");
                buf.append(ws + "obj = " + si.name + "." + si.name + "()\n");
                buf.append(ws + "buf.append(LMCPFactory.packMessage(obj, True))\n");
            }
        }
        return buf.toString();
    }

    public static String to_xml_members(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        String str = "";
        str += ws + "buf += " + extends_name(infos, info, outfile, st, en, "") + ".toXMLMembersStr(self, ws)\n";

        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (f.isArray) {
                str += ws + "buf += ws + \"<" + f.name + ">\\n\"\n";

                str += ws + "for x in " + name + ":\n";
                if (f.isStruct) {
                    str += ws + "    if x == None:\n";
                    str += ws + "        buf += ws + \"    <null/>\\n\"\n";
                    str += ws + "    else:\n";
                    str += ws + "        buf += x.toXMLStr(ws + \"    \") \n";
                } else if (f.isEnum) {
                    str += ws + "    buf += ws + \"<" + f.type + ">\" + " + f.type + ".get_" + f.type + "_int(x) + \"</" + f.type + ">\\n\"\n";
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    str += ws + "    buf += ws + \"<" + f.type + ">\" + ('True' if x else 'False') + \"</" + f.type + ">\\n\"\n";
                } else {
                    str += ws + "    buf += ws + \"<" + f.type + ">\" + str(x) + \"</" + f.type + ">\\n\"\n";
                }

                str += ws + "buf += ws + \"</" + f.name + ">\\n\"\n";
            } else if (f.isStruct) {
                str += ws + "buf += ws + \"<" + f.name + ">\\n\"\n";
                str += ws + "if " + name + " == None:\n";
                str += ws + "    buf += ws + \"    <null/>\\n\"\n";
                str += ws + "else:\n";
                str += ws + "    buf += ws + " + name + ".toXMLStr(ws + \"    \") \n";
                str += ws + "buf += ws + \"</" + f.name + ">\\n\"\n";
            } else if (f.isEnum) {
                str += ws + "buf += ws + \"<" + f.name + ">\" + " + f.type + ".get_" + f.type + "_int(" + name + ") + \"</" + f.name + ">\\n\"\n";
            } else if (f.type.equalsIgnoreCase("Bool")) {
                str += ws + "buf += ws + \"<" + f.name + ">\" + ('True' if " + name + " else 'False') + \"</" + f.name + ">\\n\"\n";
            } else {
                str += ws + "buf += ws + \"<" + f.name + ">\" + str(" + name + ") + \"</" + f.name + ">\\n\"\n";
            }
        }

        return str;
    }
    public static String to_dict_members(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        String str = "";
        str += ws + extends_name(infos, info, outfile, st, en, "") + ".toDictMembers(self, d)\n";

        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (f.isArray) {
                str += ws + "d['" + f.name + "'] = []\n";

                str += ws + "for x in " + name + ":\n";
                if (f.isStruct) {
                    str += ws + "    if x == None:\n";
                    str += ws + "        d['" + f.name + "'].append(None)\n";
                    str += ws + "    else:\n";
                    str += ws + "        d['" + f.name + "'].append(x.toDict())\n";
                } else {
                    str += ws + "    d['" + f.name + "'].append(x)\n";
                }
            } else if (f.isStruct) {
                str += ws + "if " + name + " == None:\n";
                str += ws + "    d['" + f.name + "'] = None\n";
                str += ws + "else:\n";
                str += ws + "    d['" + f.name + "'] = " + name + ".toDict()\n";
            } else {
                str += ws + "d['" + f.name + "'] = " + name + "\n";
            }
        }

        return str;
    }

    public static String members_from_xml(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + extends_name(infos, info, outfile, st, en, "") + ".unpackFromXMLNode(self, el, seriesFactory)\n" );
        if (st.fields.length > 0) {
            buf.append(ws + "for e in el.childNodes:\n");
            buf.append(ws + "    if e.nodeType == xml.dom.Node.ELEMENT_NODE:\n");
        }
        boolean first = true;
        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (first) {
                buf.append(ws + "        if e.localName == \"" + f.name + "\" and len(e.childNodes) > 0 :\n");
                first = false;
            }
            else {
                buf.append(ws + "        elif e.localName == \"" + f.name + "\" and len(e.childNodes) > 0 :\n");
            }
            if (!f.isArray) {
                if (f.isStruct) {
                    buf.append(ws + "            for n in e.childNodes:\n" );
                    buf.append(ws + "                if n.nodeType == xml.dom.Node.ELEMENT_NODE:\n");
                    buf.append(ws + "                    " + name + " = seriesFactory.createObjectByName(n.getAttribute('Series'), n.localName)\n");
                    buf.append(ws + "                    if " + name + " != None:\n");
                    buf.append(ws + "                        " + name + ".unpackFromXMLNode(n, seriesFactory)\n");
                } else if (f.isEnum) {
                    buf.append(ws + "            " + name + " = " + f.type  + ".get_" + f.type + "_str(e.childNodes[0].nodeValue)\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "            " + name + " = e.childNodes[0].nodeValue.lower() == 'true'\n");
                } else {
                    buf.append(ws + "            " + name + " = " + getPythonType(f.type) + "(e.childNodes[0].nodeValue)\n");
                }
            // struct arrays
            } else {
                buf.append(ws + "            " + name + " = []\n");
                buf.append(ws + "            for c in e.childNodes:\n");
                buf.append(ws + "                if c.nodeType == xml.dom.Node.ELEMENT_NODE:\n");
                if (f.isStruct) {
                    buf.append(ws + "                    obj = seriesFactory.createObjectByName(c.getAttribute('Series'), c.localName)\n");
                    buf.append(ws + "                    if obj != None:\n");
                    buf.append(ws + "                        obj.unpackFromXMLNode(c, seriesFactory)\n");
                    buf.append(ws + "                        " + name + ".append(obj)\n");
                }
                else if (f.isEnum) {
                    buf.append(ws + "                    " + name + ".append( " + f.type + ".get_" + f.type + "_str(c.childNodes[0].nodeValue) )\n");
                } else if (f.type.equalsIgnoreCase("Bool")) {
                    buf.append(ws + "                    " + name + ".append( c.childNodes[0].nodeValue.lower() == 'true' )\n");
                } else {
                    buf.append(ws + "                    " + name + ".append( " + getPythonType(f.type) + "(c.childNodes[0].nodeValue) )\n");
                }
            }
        }
        return buf.toString();
    }
    
    public static String members_from_dict(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        buf.append(ws + extends_name(infos, info, outfile, st, en, "") + ".unpackFromDict(self, d, seriesFactory)\n" );
        if (st.fields.length > 0) {
            buf.append(ws + "for key in d:\n");
        }
        
        boolean first = true;
        for (FieldInfo f : st.fields) {
            String name = "self." + f.name;
            if (first) {
                buf.append(ws + "    if key == \"" + f.name + "\":\n");
                first = false;
            }
            else {
                buf.append(ws + "    elif key == \"" + f.name + "\":\n");
            }
            if (!f.isArray) {
                if (f.isStruct) {
                    buf.append(ws + "        " + name + " = seriesFactory.unpackFromDict(d[key])\n");
                } else {
                    buf.append(ws + "        " + name + " = d[key]\n");
                }
            // struct arrays
            } else {
                buf.append(ws + "        " + name + " = []\n");
                buf.append(ws + "        for c in d[key]:\n");
                if (f.isStruct) {
                    buf.append(ws + "            obj = seriesFactory.unpackFromDict(c)\n");
                    buf.append(ws + "            if obj != None:\n");
                    buf.append(ws + "                " + name + ".append(obj)\n");
                } else {
                    buf.append(ws + "            " + name + ".append( c )\n");
                }
            }
        }
        return buf.toString();
    }

    public static String obj_by_name(MDMInfo[] infos, MDMInfo info, File outfile, StructInfo st, EnumInfo en, String ws) throws Exception {
        StringBuffer buf = new StringBuffer();
        for(StructInfo d : info.structs) {
            buf.append(ws + "if name == \"" + d.name + "\":\n");
            buf.append(ws + "    return " + d.name + "." + d.name + "()\n");
        }
        return buf.toString();
        
    }

    private static String getNamespaceForSeries(MDMInfo[] infos, StructInfo st) throws Exception {
        for(MDMInfo info : infos){
            for(StructInfo s : info.structs){
                if(st.extends_name.equals(s.name)){
                    return s.namespace;
                }
            }
        }
        return null;
    }

    private static String getNamespaceForType(MDMInfo[] infos, FieldInfo f) throws Exception {
        for(MDMInfo info : infos){
            if(f.isStruct){
                for(StructInfo si : info.structs){
                    if(f.type.equals(si.name)){
                        return si.namespace;
                    }
                }
            }
            if(f.isEnum){
                for(EnumInfo ei : info.enums){
                    if(f.type.equals(ei.name)){
                        //System.out.println("Enum namespace: " + ei.namespace + "Enum type: " + ei.name);
                        return ei.namespace;
                    }
                }
            }
        }
        return null;
    }

    private static String getPythonType(String type) {

        if (type.toLowerCase().matches("(bool)")) {
            return "bool";
        }
        if (type.toLowerCase().matches("(string)|(char)")) {
            return "str";
        }
        if (type.toLowerCase().matches("(byte)|(int64)|(int32)|(uint32)|(int16)|(uint16)")) {
            return "int";
        }
        if (type.toLowerCase().matches("(real32)|(real64)")) {
            return "float";
        }
        if (type.equalsIgnoreCase(MDMInfo.LMCP_OBJECT_NAME)) {
            return "LMCPObject";
        }
        return type;
    }

    private static String getStructTypeString(FieldInfo field) throws Exception {
        if (field.isEnum) {
            return "i";
        }
        String LMCPType = field.type;
        if (LMCPType.equalsIgnoreCase("real32")) {
            return "f";
        } else if (LMCPType.equalsIgnoreCase("real64")) {
            return "d";
        } else if (LMCPType.equalsIgnoreCase("int16")) {
            return "h";
        } else if (LMCPType.equalsIgnoreCase("int32")) {
            return "i";
        } else if (LMCPType.equalsIgnoreCase("int64")) {
            return "q";
        } else if (LMCPType.equalsIgnoreCase("uint16")) {
            return "H";
        } else if (LMCPType.equalsIgnoreCase("uint32")) {
            return "I";
        } else if (LMCPType.equalsIgnoreCase("bool")) {
            // would prefer to use "?" character, but python 2.6 seems to not like it
            return "B";
        } else if (LMCPType.equalsIgnoreCase("char")) {
            return "c";
        } else if (LMCPType.equalsIgnoreCase("byte")) {
            return "B";
        }
        throw new Exception("Invalid Struct");
    }

    /** returns the size in bytes of the LMCP type */
    private static int sizeOf(FieldInfo field) throws Exception {
        if (field.isEnum) {
            return 4;
        }
        String type = field.type;
        if (type.toLowerCase().matches("(byte)|(char)|(bool)")) {
            return 1;
        }
        if (type.toLowerCase().matches("(int16)|(uint16)")) {
            return 2;
        }
        if (type.toLowerCase().matches("(int32)|(uint32)|(real32)")) {
            return 4;
        }
        if (type.toLowerCase().matches("(int64)|(real64)")) {
            return 8;
        }
        throw new Exception("Invalid Struct");
    }
}
